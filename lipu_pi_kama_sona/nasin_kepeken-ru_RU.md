Смотреть на другом языке: [English](nasin_kepeken-en_US.md "View in English"), [toki pona](nasin_kepeken-tok.md "lukin kepeken toki pona")

# **Документация языка ilo li sina**

ilo li sina - маленький эзотерический язык, который работает только со строками, но даже  только с этим вы все еще можете сделать много интересных и полезных.

Все в ilo li sina - строки или работают со строками. Чтобы создать строковые литералы, напишите текст внутри пары кавычек (например, "test" и "вот это строковый литерал")

## **Особенности языка**

---------------

### ***Функции***

ilo li sina имеет несколько функций. Все они получают список строк как аргументы и возвращают строку. Для использования функции напишите имя, а затем аргуметы внутри круглых скобок.

Аргументы разделяются пробелами, но не нужно там, где другие символы, с которыми разделение можно (например с литералами). Но выглядит лучше это сделать, даже если так.

```ilo li sina
    tokiELinja("это" " строка") # Правильно. Скажет "это строка".
    tokiELinja("это"" строка") # Правильно.
    a = "это"
    tokiELinja(a " строка") # Правильно.
    tokiELinja(a" строка") # Правильно.
    б = " строка"
    tokiELinja(a б) # Правильно.
    tokiELinja(aб) # Неправильно. Переменная не "a" и "b", а "aб", которую не инициализировало.
```

Можно дать результат функции как аргумент другой функцию:

```ilo li sina
    # Скажет то, что сказал пользователь.
    tokiELinja("Вы сказали: " kamaJo()) 

    tokiELinja("Вас зовут " kamaJo("Как вас зовут? "))
```

Вы можете сделать функию (ближе к процедурам) по-своему с помощью lawa(), поставляя весь код той функции в 1 строку и давая ее в вызов lawa(). Если многострочная функция нужна, вы должны разделить каждую строку с newline (\\n). Рекомендую написать строки кода в отделных строках и объединить их с wan().

```ilo li sina
    приветствовать = "tokiELinja(\"Здравствуйте, \" имя)"
    
    имя = __nimi_jan
    lawa(приветствовать) # Приветствует ползователя.
    имя = "мир"
    lawa(приветствовать) # Говорит "Здраствуйте, мир".

    говоритОЖелании = wan("желание = kamaJo(\"Что желаете? \")\n"                       \
                          "tokiELinja(желание \" - это четкая вещь\")\n"                \
                          "tokiELinja(\"Я хочу, чтобы вы могли получить \" желание)\n")
    lawa(говоритОЖелании)
    # $ Что желаете? деньги
    # $ деньги - это четкая вещь
    # $ Я хочу, чтобы вы могли получить деньги
```

Изменения к переменным внутри lawa() произойдет вне её. Возможно сделать с этим процедуру - возвратить результат просто поставьте строку в переменную.

```ilo li sina
    говоритОЖелании = wan("желание = kamaJo(\"Что желаете? \")\n"                       \
                          "tokiELinja(желание \" - это четкая вещь\")\n"                \
                          "tokiELinja(\"Я хочу, чтобы вы могли получить \" желание)\n")
    lawa(говоритОЖелании)

    tokiELinja("Хахаха! Я знаю твой секрет! Хочешь " желание)
```

Вот все функции:

#### **toki(\[сообщения...\]) -> ничего**

Отображает сообщение пользователью.

#### **tokiELinja(\[сообщения...\]) -> ничего**

Как toki(), а после сообщении отображает перенос строки.

#### **tokiEIke(\[сообщения...\]) -> ничего**

Как toki(), а выводит в stderr вместо stdout.

#### **tokiEIkeELinja(\[сообщения...\]) -> ничего**

Как tokiELinja(), а выводит в stderr вместо stdout.

#### **kamaJo(\[сообщения...\]) -> пользовательский ввод**

Вызывает с сообщениями toki(), и получает и возвращает ввод от пользователя. Блокирует до получения ввода.

#### **alaEIloPana() -> ничего**

Очищает терминал.

*Поддерживается на Windows и UNIX.*

#### **wan(строка строка \[строки...\]) -> объединенная строка**

Объединяет строки и возвращает результат.

#### **awen(время \[времена...\]) -> ничего**

Приостанавливает программу на время в миллисекундах, полученное из суммы данных времен. Строки времен должны быть похожи на целые числа (как "400" или "1369"). awen() игнорирует пустые строки (например, "awen("200" _)" - правильно и ждать за 200 миллисекунд).

#### **pilin(строка строка \[строки...\]) -> 1 строка из данных строк**

Выбирает из данных 1 строку случайно.

#### **pokiPiLawaOS(имя \[имена...\]) -> строка в переменной среды | ничего**

Получает строку, храненную в данной переменной среды.

Имена - возможные имена нужной переменной. Ищет переменную именами одно за другим до того, как существует и получило из нее непустую строку. 

Имя пользователя к примеру сохраняется в "USER" или "LOGNAME" на Линуксе, а в "USERNAME" на Windows. А что, если хотите, чтобы работало на Линуксе и Windows? То просто напишпите все варианты как аргументы функцию pokiPiLawaOS() (только для примера, используйте предварительно инициализированную переменную __nimi_jan вместо этого).

Если под именами отсуствует переменной или строка в них пустая, то возвращает пустую строку.

## **lawa([строки...]) -> ничего**

Создает код из данных строк, где каждая строка как строка файла, и его выполняет. Он использует те же переменные, как и в главной программе, так что можно создать процедуры. Смотрите наверх для подробней информации. 

### ***Переходы***

ilo li sina использует GOTO, чтобы перемещать по программе.

GOTO нужна метка, на которую перемещать. Для создания напишите имя и точку с запятой в начале строки.

```ilo li sina
    tawa(Метка)
    tokiELinja("Это сообщение не отобразится!")
Метка:
```

tawa() переместит на "Myetka:", поэтому вызов tokiELinja() никогда не произойдет.

Для условных переходов можно использовать niLaTawa().

```ilo li sina
Продожить:
    tokiELinja("Я прдолжаю это говоить!")
    niLaTawa(Продожить "продолжить" "остановить"     \
             "Продолжить? [продолжить/остановить] ")
    tokiELinja("Я не продолжу это говорить(((")
``` 

Если пользователь отвечал "продолжить", то niLaTawa() перемещает на "Prodolzhit:", создающая цикл. А если когда-либо ответил "остановить", то цикл и программа завершатся.

Для условных переходов тоже можно использовать alaLaTawa(). Если все в ней строки - пустые, то перемещает.

```ilo li sina
    tawa(ПолучитьИмя)
ИмениНет:
    tokiELinja("Вы ничего не сказали!")
ПолучитьИмя:
    имя = kamaJo("Как вас зовут? ")
    alaLaTawa(ИмениНет имя)
    tokiELinja("Здравствуйте, " имя "!")
```

Если пользователь не отвечал, а просто нажал Enter, то перемещает на "ImyeniNyet:" и спрашивает имя снова и снова до ответа.

Вот почему есть alaLaTawa(): несколько функции и других вещи возврашают пустую строку, если ошибка (или что-нибудь похоже) произошла. Для этого можно использовать alaLaTawa() и не niLaTawa(), с которой отобразилась бы строка пользователю и ответ нужен. Есть ситуации, где это может не хочется.

GOTO перемещают только после того, как все инструкции в строки выполнились, поэтому можно использовать как обычные функции.

```ilo li sina
    # Если пользователь не отвечал да, то ответ хранится в vvod.
Лох: ввод = niLaTawa(СказалПравду "да" _             \
        "kijetesantakalu лучшее слово в токипоне? [да] "))

    tokiELinja("Чего такое \"" ввод "\"? Никогда в своей жизни не слышал об хуйне такого уровня долбоеба блять")
    awen("1500")
    tawa(Лох)

СказалПравду:
    tokiELinja("Точно!")
    awen("1500")


    # tokiELinja() говорит выбор пользователя. 
    #
    # awen() ждет, даже если niLaTawa() переместит. 
    #   В общем awen() генерирует ошибку со строками, не похожи на целые числа, 
    #   но игнорирует пустые строки. Поскольку niLaTawa() всегда возвращает пустую
    #   строку, awen() не сгенерирует ошибок.
    awen("1500" tokiELinja(                                          \
        "Вы выбрали "                                                \
        niLaTawa(Лох "продолжить" "остановить"                       \
            "Хотите продолжить программу? [продолжить/остановить] ") \
        " программу"))
```

При использовании awen() может хотите проверить без ошибки если строка похожа на целое число. Это возможно сделать с помощью nanpaLaTawa(), которая перемещает только если все строки ей так похожи.

```ilo li sina
неЧисло:
    возможноеЧисло = kamaJo("Скажите число! ")
    nanpaLaTawa(число возможноеЧисло)
    tokiELinja("'" возможноеЧисло "' не число!")
    tawa(неЧисло)

число:
    tokiELinja("Вам " возможноеЧисло " лет? Так долго, страик! хахаха")
```

Вы можете сделать случайные переходов с помощью alaLaTawa() и pilin(). Для этого дайте pilin() пустые и непустые строки, из которых деление суммы пустых на сумму пустых и непустых создаёт возможность перемещать. Например, если хотели перемешать шансом 30% (или 3/10), использовуйте alaLaTawa(метка pilin(_ _ _ "1" "2" "3" "4" "5" "6" "7")). Значение не должно быть число. Всё, что важно, в том, что они непустые.

Вот все GOTO на ilo li sina:

#### **tawa(метка) -> ничего**

Перемещает на метку.

#### **niLaTawa(метка сообщениеДа сообщениеНет \[сообщения...\]) -> пользовательский ввод**

Вызывает toki() с сообщениям. Блокирует до получения ввода пользователя. Если пользователь отвечал сообщения да, то перемещает на метку, а если отвечал сообщение нет, то нет. Возвращает ввод от пользователя.

Если либо сообщение да пустое, либо сообщение нет, но не оба в одновременно, то будет подстановочный знак.

Например, если вы использовали бы пустую строку как сообщения да и "test" для сообщения нет, если пользователь ответил "test", то не переместит, а если ответил что-либо другое, то будет.

Если сообщения да и нет пустое и пользователь отвечал что-нибудь другое, то будет спрашивать снова и снова до получения одного из них.

#### **alaLaTawa(метка строка \[строки...\]) -> ничего**

Перемещает на метку, если все строки пустые.

#### **nanpaLaTawa(метка возможноеЧисло \[возможныеЧисла...\]) -> ничего**

Перемешает на метку, если все данные строки похожи на целые числа.

### ***Переменные***

Есть переменные для хранения данных. Для хранения строки напишите имя переменной и что-нибудь, которое строка или возвращает строку, с знаком равенства между ними. Можно дать строку в них функции и другим переменным.

```ilo li sina
    a = "test"
    б = a
    tokiELinja(б) # Скажет "test"

    a = kamaJo("Что вам будет угодно? ")
    tokiELinja("У вас никогда не будет " a) # Если ответил "деньги", то скажет "У вас никогда не будет деньни".

    вещь = "вещь"
Больше:
    niLaTawa(Хватит "нет" "да"                    \
             "Вы хотите больше вещей? [да/нет] ")
    вещь = wan(вещь вещь)
    tawa(Больше)
Хватит:
    tokiELinja(вещь) # Если пользователь выбирал "да" 4 раза, то скажет "вещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещь".
```

### ***Маленькие Особенности***

#### *Управляющие символы:*

Можно добавить управляющий символ в литерале, написав обратную косую черту и его символ.

 - \\n - Перенос строки.
 - \\t - Табуляция.
 - \\v - Вертикальная табуляция.
 - \\b - Backspace.
 - \\" - Позволяет сделать кавычки в строках.
 - \\\\ - Позволяет сделать обратные косые черты в строках.

Например:

```ilo li sina
    toki("Это язык \"ilo li sina\" !\b\b") # Скажет 'Это язык "ilo li sina"'.
```

#### *Многострочные инструкции:*

Инструкции в ilo li sina разделяются переносами строки - так сказать, каждая инструкция начинается и заканчивается в одной строке. Но можно сделать одну инструкцию многострочной, писав обратную косую черту в конце каждой строки инструкции кроме последней.

```ilo li sina
    aбв  \
    =    \
    "да"
    niLaTawa(Знает aбв "нет"                               \
            "Знаете ли вы пряничного человека? [да/нет] ")

    tokiELinja("Это сообщение " "в" \
               " многих"            \
               " строках!")

    tawa(Конец)

Знает: tokiELinja(          \
                            \
                            \
                            \
                            \
                            \
                            \
                  "Круто!")

Конец:
```

#### *Получение EOF:*

kamaJo() и niLaTawa() завершают программу при получении EOF.

Вот почему: все языка - IO. Если нет ввода, то ничего не может сделать. Хотя, это и позволяет чтение из файлов. К примеру, если вы бы создали файл с именем "temp.txt", написали текста в нем и запустил "temp.txt | ilo_li_sina \<имя прогаммы\>", то программа получил бы ввод из него без бесконечного цикла.

#### *Предварительно инициализированные переменные:*

Немного переменных инициализируются до начала каждой программы на ilo li sina.

**__nanpa_Ilo_Li_Sina** - Версия интерпретатора.

**__nimi_Ilo_Li_Sina** - Путь к испольняемому интерпретатора.

**__nimi_lipu** - Путь к выбранной программе.

**__nimi_jan** - Имеет имя пользователя, полученное из вызова функцию pokiPiLawaOS("USER" "USERNAME" "LOGNAME"). Если не удалось, то имеет пустую строку.

**_** - Сокращение пустой строки ("").