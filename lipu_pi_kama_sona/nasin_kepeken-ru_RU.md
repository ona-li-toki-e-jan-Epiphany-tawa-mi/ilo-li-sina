Смотреть на другом языке: [English](nasin_kepeken-en_US.md "View in English"), [toki pona](nasin_kepeken-tok.md "lukin kepeken toki pona")

# **Документация языка ilo li sina**

ilo li sina - маленький эзотерический язык, который работает только со строками, но даже  только с этим вы все еще можете сделать много интересных и полезных.

Все в ilo li sina - строки или работают со строками. Чтобы создать строковые литералы, напишите текст внутри пары двойных или одинарных кавычек, или обратных апострофов (например, `"test"` и `'вот это строковый литерал'`).

## **Особенности языка**

---------------

### ***Функции***

ilo li sina имеет несколько функций. Все они получают список строк как аргументы и возвращают строку. Для использования функции напишите имя, а затем аргуметы внутри круглых скобок.

Аргументы разделяются пробелами, но не нужно там, где другие символы, с которыми разделение можно (например с литералами). Но выглядит лучше это сделать, даже если так.

```ilo li sina
    tokiELinja("это" " строка") # Правильно. Скажет "это строка".
    tokiELinja("это"" строка") # Правильно.
    a = "это"
    tokiELinja(a " строка") # Правильно.
    tokiELinja(a" строка") # Правильно.
    б = " строка"
    tokiELinja(a б) # Правильно.
    tokiELinja(aб) # Неправильно. Переменная не "a" и "b", а "aб", которую не инициализировало.
```

Можно дать результат функции как аргумент другой функцию:

```ilo li sina
    # Скажет то, что сказал пользователь.
    tokiELinja("Вы сказали: " kamaJo()) 

    tokiELinja("Вас зовут " kamaJo("Как вас зовут? "))
```

Вы можете сделать функию (ближе к процедурам) по-своему с помощью `lawa()`, поставляя весь код той функции в 1 строку и давая ее в вызов `lawa()`. Если многострочная функция нужна, вы должны разделить каждую строку с newline (`\n`). Рекомендую написать строки кода в отделных строках и объединить их с `wan()`.

```ilo li sina
    приветствовать = "tokiELinja(`Здравствуйте, ` имя `!`)"
    
    имя = __nimi_jan
    lawa(приветствовать) # Приветствует ползователя.
    имя = "мир"
    lawa(приветствовать) # Говорит "Здраствуйте, мир".

    говоритОЖелании = wan("желание = kamaJo(`Что желаете? `)                      \n"  \
                          "tokiELinja(желание ` - это четкая вещь`)               \n"  \
                          "tokiELinja(`Я хочу, чтобы вы могли получить ` желание) \n")
    lawa(говоритОЖелании)
    # $ Что желаете? деньги
    # $ деньги - это четкая вещь
    # $ Я хочу, чтобы вы могли получить деньги
```

Изменения к переменным внутри `lawa()` произойдет вне её. Возможно сделать с этим процедуру - возвратить результат просто поставьте строку в переменную.

```ilo li sina
    говоритОЖелании = wan("желание = kamaJo(`Что желаете? `)                      \n"  \
                          "tokiELinja(желание ` - это четкая вещь`)               \n"  \
                          "tokiELinja(`Я хочу, чтобы вы могли получить ` желание) \n")
    lawa(говоритОЖелании)

    tokiELinja("Хахаха! Я знаю твой секрет! Хочешь " желание)
```

Вот все функции:

#### **toki(\[сообщения...\]) -> ничего**

Отображает `сообщение` пользователью.

#### **tokiELinja(\[сообщения...\]) -> ничего**

Как `toki()`, а после `сообщении` отображает перенос строки.

#### **tokiEIke(\[сообщения...\]) -> ничего**

Как `toki()`, а выводит в `stderr` вместо `stdout`.

#### **tokiEIkeELinja(\[сообщения...\]) -> ничего**

Как `tokiELinja()`, а выводит в `stderr` вместо `stdout`.

#### **kamaJo(\[сообщения...\]) -> пользовательский ввод**

Вызывает с `сообщениями` `toki()`, и получает и возвращает `ввод` от пользователя. Блокирует до получения `ввода`.

#### **alaEIloPana() -> ничего**

*`Поддерживается на Windows и UNIX.`*

Очищает терминал.

#### **wan(строка строка \[строки...\]) -> объединенная строка**

Объединяет `строки` и возвращает `результат`.

#### **awen(время \[времена...\]) -> ничего**

Приостанавливает программу на время в миллисекундах, полученное из суммы данных `времен`. Строки `времен` должны быть похожи на целые числа (как `"400"` или `"1369"`). `awen()` игнорирует пустые строки (например, `awen("200" _)` - правильно и ждать за `200` миллисекунд).

#### **pilin(строка строка \[строки...\]) -> 1 строка из данных строк**

Выбирает из `данных` 1 `строку` случайно.

#### **pokiPiLawaOS(имя \[имена...\]) -> строка в переменной среды | ничего**

Получает строку, храненную в данной переменной среды.

`Имена` - возможные имена нужной переменной. Ищет переменную `именами` одно за другим до того, как существует и получило из нее непустую строку. 

Имя пользователя к примеру сохраняется в `USER` или `LOGNAME` на Линуксе, а в `USERNAME` на Windows. А что, если хотите, чтобы работало на Линуксе и Windows? То просто напишпите все варианты как аргументы функцию `pokiPiLawaOS()` (только для примера, используйте предварительно инициализированную переменную `__nimi_jan` вместо этого).

Если под `именами` отсуствует переменной или строка в них пустая, то возвращает `пустую строку`.

#### **lawa(\[строки...\]) -> ничего**

Создает код из данных `строк`, где каждая `строка` как строка файла, и его выполняет. Он использует те же переменные, как и в главной программе, так что можно создать процедуры. Смотрите наверх для подробней информации. 

#### **ikeLaTawaAla() -> ничего**

Посмотрите [Обработку Ошибок.](nasin_kepeken-ru_RU.md#обработка-ошибок "Обработка Ошибок")

#### **ike(\[строки\]) -> ничего**

Летает ошибки с сообщением, созданные из объединения данных `строк`.

### ***Переходы***

ilo li sina использует GOTO, чтобы перемещать по программе.

GOTO нужна метка, на которую перемещать. Для создания напишите имя и точку с запятой в начале строки.

```ilo li sina
    tawa(Метка)
    tokiELinja("Это сообщение не отобразится!")
Метка:
```

`tawa()` переместит на `Myetka:`, поэтому вызов `tokiELinja()` никогда не произойдет.

Для условных переходов можно использовать `niLaTawa()`.

```ilo li sina
Продожить:
    tokiELinja("Я прдолжаю это говоить!")
    niLaTawa(Продожить "продолжить" "остановить"     \
             "Продолжить? [продолжить/остановить] ")
    tokiELinja("Я не продолжу это говорить(((")
``` 

Если пользователь отвечал продолжить, то `niLaTawa()` перемещает на `Prodolzhit:`, создающая цикл. А если когда-либо ответил остановить, то цикл и программа завершатся.

Для условных переходов тоже можно использовать `alaLaTawa()`. Если все в ней строки - пустые, то перемещает.

```ilo li sina
    tawa(ПолучитьИмя)
ИмениНет:
    tokiELinja("Вы ничего не сказали!")
ПолучитьИмя:
    имя = kamaJo("Как вас зовут? ")
    alaLaTawa(ИмениНет имя)
    tokiELinja("Здравствуйте, " имя "!")
```

Если пользователь не отвечал, а просто нажал `Enter`, то перемещает на `ImyeniNyet:` и спрашивает имя снова и снова до ответа.

Вот почему есть `alaLaTawa()`: несколько функции и других вещи возврашают пустую строку, если ошибка (или что-нибудь похоже) произошла. Для этого можно использовать `alaLaTawa()` и не `niLaTawa()`, с которой отобразилась бы строка пользователю и ответ нужен. Есть ситуации, где это может не хочется.

GOTO перемещают только после того, как все инструкции в строки выполнились, поэтому можно использовать как обычные функции.

```ilo li sina
    # Если пользователь не отвечал да, то ответ хранится в vvod.
Лох: ввод = niLaTawa(СказалПравду "да" _             \
        "kijetesantakalu лучшее слово в токипоне? [да] "))

    tokiELinja("Чего такое \"" ввод "\"? Никогда в своей жизни не слышал об хуйне такого уровня долбоеба блять")
    awen("1500")
    tawa(Лох)

СказалПравду:
    tokiELinja("Точно!")
    awen("1500")


    # tokiELinja() говорит выбор пользователя. 
    #
    # awen() ждет, даже если niLaTawa() переместит. 
    #   В общем awen() генерирует ошибку со строками, не похожи на целые числа, 
    #   но игнорирует пустые строки. Поскольку niLaTawa() всегда возвращает пустую
    #   строку, awen() не сгенерирует ошибок.
    awen("1500" tokiELinja(                                          \
        "Вы выбрали "                                                \
        niLaTawa(Лох "продолжить" "остановить"                       \
            "Хотите продолжить программу? [продолжить/остановить] ") \
        " программу"))
```

Вы можете сделать случайные переходов с помощью `alaLaTawa()` и `pilin()`. Для этого дайте `pilin()` пустые и непустые строки, из которых деление суммы пустых на сумму пустых и непустых создаёт возможность перемещать. Например, если хотели перемешать шансом `30%` (или `3/10`), использовуйте `alaLaTawa(метка pilin(_ _ _ "1" "2" "3" "4" "5" "6" "7"))`. Значение не должно быть число. Всё, что важно, в том, что они непустые.

Вот все GOTO на ilo li sina:

#### **tawa(метка) -> ничего**

Перемещает на `метку`.

#### **niLaTawa(метка сообщениеДа сообщениеНет \[сообщения...\]) -> пользовательский ввод**

Вызывает `toki()` с `сообщениям`. Блокирует до получения `ввода пользователя`. Если пользователь отвечал `сообщения да`, то перемещает на `метку`, а если отвечал `сообщение нет`, то нет. Возвращает `ввод от пользователя`.

Если либо `сообщение да` пустое, либо `сообщение нет`, но не оба одновременно, то будет подстановочный знак.

Например, если вы использовали бы пустую строку как `сообщения да` и `"test"` для `сообщения нет`, если пользователь ответил `"test"`, то не переместит, а если ответил что-либо другое, то будет.

Если `сообщение да` и `сообщение нет` пустое и пользователь отвечал что-нибудь другое, то будет спрашивать снова и снова до получения одного из них.

#### **alaLaTawa(метка строка \[строки...\]) -> ничего**

Перемещает на `метку`, если все `строки` пустые.

#### **ikeLaTawa(метка) -> ничего**

Посмотрите [Обработку Ошибок.](nasin_kepeken-ru_RU.md#обработка-ошибок "Обработка Ошибок")

### **Переменные**

Есть переменные для хранения данных. Для хранения строки напишите имя переменной и что-нибудь, которое строка или возвращает строку, с знаком равенства между ними. Можно дать строку в них функции и другим переменным.

```ilo li sina
    a = "test"
    б = a
    tokiELinja(б) # Скажет "test"

    a = kamaJo("Что вам будет угодно? ")
    tokiELinja("У вас никогда не будет " a) # Если ответил "деньги", то скажет "У вас никогда не будет деньни".

    вещь = "вещь"
Больше:
    niLaTawa(Хватит "нет" "да"                    \
             "Вы хотите больше вещей? [да/нет] ")
    вещь = wan(вещь вещь)
    tawa(Больше)
Хватит:
    tokiELinja(вещь) # Если пользователь выбирал "да" 4 раза, то скажет "вещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещь".
```

### **Обработка Ошибок**

Функции могут летить ошибки. Например, `awen()` так делает, если получил строку, которая не похожа на число. Также `lawa()`, если либо программа, которая далась ей, неправильная, либо ошибку летили внутри. По умолчанию программа завершит, когда ошибку летит [*найс))*], а это можно изменить вызовами `ikeLaTawa()` и `ikeLaTawaAla()`. `ikeLaTawa()` устанавливает, куда перемещать при ошибках.

```ilo li sina
Начало:
    возраст = kamaJo("Сколько вам лет? ")

    ikeLaTawa(Ошибалось)
    awen(возраст)
    tokiELinja("Терерь вы " возраст " миллисекунд(а) постарше!")

    tawa(Конец)
Ошибалось:
    tokiELinja("'" возраст "' не число!")
    tawa(Начало)
Конец:
```

Если пользователь поговорил число, программа будет ждать и завершит, но, если поговорил что-то другое, то `awen()` летит ошибку, и интерпретатор переместит на `ike:` и повторит вопрос.

taso, ni li pini ala. ona li toki e ijo pi nanpa ala la `kamaJo()` li lawa sin la ona li pilin e nena `Ctrl-D` tawa pini la ona li lukin e ni:

Но это не завершенно. Если он поговорил нечисло и, после, исползовал `Ctrl+D`, чтобы завершить программа, увидет вот это:

```console
Сколько вам лет? число
ilo_li_sina: <имя файла>(6,5): Ошибка: awen(): Ожидалось
        целое число, но получилось «число»
'число' не число!
Сколько вам лет?
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
Сколько вам лет? 
... 
```

Жесть! После вызова `ikeLaTawa()` и кода, которому тот вызов нужен, вы должны вызовить `ikeLaTawaAla()`, чтобы редотвратить такие проблемы.

```ilo li sina
Начало:
    возраст = kamaJo("Сколько вам лет? ")

    ikeLaTawa(Ошибалось)
    awen(возраст)
    ikeLaTawaAla()

    tokiELinja("Терерь вы " возраст " миллисекунд(а) постарше!")


    tawa(Конец)
Ошибалось:
    ikeLaTawaAla()
    tokiELinja("'" возраст "' не число!")
    tawa(Начало)
Конец:
```

### ***Маленькие Особенности***

#### *Управляющие символы:*

Можно добавить управляющий символ в литерале, написав обратную косую черту и его символ.

 - `\n` - Перенос строки.
 - `\t` - Табуляция.
 - `\v` - Вертикальная табуляция.
 - `\b` - Backspace.
 - `\"` - Позволяет двойные кавычки в строках.
 - `\'` - Позволяет одинарные кавычки в строках.
 - `` \` `` - Позволяет сделать обратные апострофы в строках.
 - `\\` - Позволяет сделать обратные косые черты в строках.

Например:

```ilo li sina
    toki("Это язык \"ilo li sina\" !\b\b") # Скажет 'Это язык "ilo li sina"'.
```

#### *Многострочные инструкции:*

Инструкции в ilo li sina разделяются переносами строки - так сказать, каждая инструкция начинается и заканчивается в одной строке. Но можно сделать одну инструкцию многострочной, писав обратную косую черту в конце каждой строки инструкции кроме последней.

```ilo li sina
    aбв  \
    =    \
    "да"
    niLaTawa(Знает aбв "нет"                               \
            "Знаете ли вы пряничного человека? [да/нет] ")

    tokiELinja("Это сообщение " "в" \
               " многих"            \
               " строках!")

    tawa(Конец)

Знает: tokiELinja(          \
                            \
                            \
                            \
                            \
                            \
                            \
                  "Круто!")

Конец:
```

#### *Получение EOF:*

`kamaJo()` и `niLaTawa()` завершают программу при получении EOF.

Вот почему: все языка - IO. Если нет ввода, то ничего не может сделать. Хотя, это и позволяет чтение из файлов. К примеру, если вы бы создали файл с именем `temp.txt`, написали текста в нем и запустил `temp.txt | ilo_li_sina <имя прогаммы>`, то программа получил бы ввод из него без бесконечного цикла.

#### *Предварительно инициализированные переменные:*

Немного переменных инициализируются до начала каждой программы на ilo li sina.

**__nanpa_Ilo_Li_Sina** - Версия интерпретатора.

**__nimi_Ilo_Li_Sina** - Путь к испольняемому интерпретатора.

**__nimi_lipu** - Путь к выбранной программе.

**__nimi_jan** - Имеет имя пользователя, полученное из оператцонной системы. Если не удалось, то имеет пустую строку.

**_** - Сокращение пустой строки ("").