Смотреть на другом языке: [English](nasin_kepeken-en_US.md "View in English"), [toki pona](nasin_kepeken-tok.md "lukin kepeken toki pona")

# **Документация языка ilo li sina**

ilo li sina - маленький эзотерический язык, который работает только со строками, но даже  только с этим вы все еще можете сделать много интересных и полезных.

Все в ilo li sina - строки или работают со строками. Чтобы создать строковые литералы, напишите текст внутри пары кавычек (например, "test" и "вот это строковый литерал")

## **Особенности языка**

---------------

### ***Функции***

ilo li sina имеет несколько функций. Все они получают список строк как аргументы и возвращают строку. Для использования функции напишите имя, а затем аргуметы внутри круглых скобок.

Аргументы разделяются пробелами, но не нужно там, где другие символы, с которыми разделение можно (например с литералами). Но выглядит лучше это сделать, даже если так.

```ilo li sina
    tokiELinja("это" " строка") # Правильно. Скажет "это строка".
    tokiELinja("это"" строка") # Правильно.
    a = "это"
    tokiELinja(a " строка") # Правильно.
    tokiELinja(a" строка") # Правильно.
    б = " строка"
    tokiELinja(a б) # Правильно.
    tokiELinja(aб) # Неправильно. Переменная не "a" и "b", а "aб", которую не инициализировало.
```

Можно дать результат функции как аргумент другой функцию:

```ilo li sina
    # Скажет то, что сказал пользователь.
    tokiELinja("Вы сказали: " kamaJoTanJan()) 

    tokiELinja("Вас зовут " kamaJoTanJan("Как вас зовут?"))
```

Вот все функции:

#### **toki(\[сообщения...\]) -> ничего**

Отображает сообщение пользователью.

#### **tokiELinja(\[сообщения...\]) -> ничего**

Как toki(), а после сообщении отображает перенос строки.

#### **tokiEIke(\[сообщения...\]) -> ничего**

Как toki(), а выводит в stderr вместо stdout.

#### **tokiEIkeELinja(\[сообщения...\]) -> ничего**

Как tokiELinja(), а выводит в stderr вместо stdout.

#### **kamaJoTanJan(\[сообщения...\]) -> пользовательский ввод**

Вызывает с сообщениями tokiELinja(), и получает и возвращает ввод от пользователя. Блокирует до получения ввода.

#### **wan(\[строки...\]) -> объединенная строка**

Объединяет строки и возвращает результат.

#### **awen(\[времена...\]) -> ничего**

Приостанавливает программу на время в миллисекундах, полученное из суммы данных времен. Строки времен должны быть похожи на целые числа (как "400" или "1369"). awen() игнорирует пустые строки (например, "awen("200" _)" - правильно и ждать за 200 миллисекунд).

#### **pokiPiLawaOS(\[имена...\]) -> строка в переменной среды | ничего**

Получает строку, храненную в данной переменной среды.

Имена - возможные имена нужной переменной. Ищет переменную именами одно за другим до того, как существует и получило из нее непустую строку. 

Имя пользователя к примеру сохраняется в "USER" или "LOGNAME" на Линуксе, а в "USERNAME" на Windows. А что, если хотите, чтобы работало на Линуксе и Windows? То просто напишпите все варианты как аргументы функцию pokiPiLawaOS() (только для примера, используйте предварительно инициализированную переменную __nimi_jan вместо этого).

Если под именами отсуствует переменной или строка в них пустая, то возвращает пустую строку.

#### **tawa(метка) -> ничего**

Перемещает на метку.

#### **niLaTawa(метка сообщениеДа сообщениеНет \[сообщения...\]) -> пользовательский ввод**

Вызывает niLaTawa() с сообщениям да и нет, и дополнительными сообщениям. Блокирует до получения ввода пользователя. Если пользователь отвечал сообщения да, то перемещает на метку, а если отвечал сообщение нет, то нет. Возвращает ввод от пользователя.

Если либо сообщение да пустое, либо сообщение нет, но не оба в одновременно, то будет подстановочный знак.

Например, если вы использовали бы пустую строку как сообщения да и "test" для сообщения нет, если пользователь ответил "test", то не переместит, а если ответил что-либо другое, то будет.

Если сообщения да и нет пустое и пользователь отвечал что-нибудь другое, то будет спрашивать снова и снова до получения одного из них.

#### **alaLaTawa(метка строка \[строки...\]) -> ничего**

Перемещает на метку, если все строки пустые.

#### **nanpaLaTawa(метка возможноеЧисло \[возможныеЧисла...\]) -> ничего**

Перемешает на метку, если все данные строки похожи на целые числа.

### ***Переходы***

ilo li sina использует GOTO, чтобы перемещать по программе.

GOTO нужна метка, на которую перемещать. Для создания напишите имя и точку с запятой в начале строки.

```ilo li sina
    tawa(Метка)
    tokiELinja("Это сообщение не отобразится!")
Метка:
```

tawa() переместит на "Myetka:", поэтому вызов tokiELinja() никогда не произойдет.

Для условных переходов можно использовать niLaTawa().

```ilo li sina
Продожить:
    tokiELinja("Я прдолжаю это говоить!")
    niLaTawa(Продожить "продолжить" "остановить" \
             "Продолжить?")
    tokiELinja("Я не продолжу это говорить(((")
``` 

Если пользователь отвечал "продолжить", то niLaTawa() перемещает на "Prodolzhit:", создающая цикл. А если когда-либо ответил "остановить", то цикл и программа завершатся.

Для условных переходов тоже можно использовать alaLaTawa(). Если все в ней строки - пустые, то перемещает.

```ilo li sina
    tawa(ПолучитьИмя)
ИмениНет:
    tokiELinja("Вы ничего не сказали!")
ПолучитьИмя:
    имя = kamaJoTanJan("Как вас зовут?")
    alaLaTawa(ИмениНет имя)
    tokiELinja("Здравствуйте, " имя "!")
```

Если пользователь не отвечал, а просто нажал Enter, то перемещает на "ImyeniNyet:" и спрашивает имя снова и снова до ответа.

Вот почему есть alaLaTawa(): несколько функции и других вещи возврашают пустую строку, если ошибка (или что-нибудь похоже) произошла. Для этого можно использовать alaLaTawa() и не niLaTawa(), с которой отобразилась бы строка пользователю и ответ нужен. Есть ситуации, где это может не хочется.

GOTO перемещают только после того, как все инструкции в строки выполнились, поэтому можно использовать как обычные функции.

```ilo li sina
    # Если пользователь не отвечал да, то ответ хранится в vvod.
Лох: ввод = niLaTawa(СказалПравду "да" _             \
        "kijetesantakalu лучшее слово в токипоне?"))

    tokiELinja("Чего такое \"" ввод "\"? Никогда в своей жизни не слышал об хуйне такого уровня долбоеба блять")
    awen("1500")
    tawa(Лох)

СказалПравду:
    tokiELinja("Точно!")
    awen("1500")


    # tokiELinja() говорит выбор пользователя. 
    #
    # awen() ждет, даже если niLaTawa() переместит. 
    #   В общем awen() генерирует ошибку со строками, не похожи на целые числа, 
    #   но игнорирует пустые строки. Поскольку niLaTawa() всегда возвращает пустую
    #   строку, awen() не сгенерирует ошибок.
    awen("1500" tokiELinja(                     \
        "Вы выбрали "                           \
        niLaTawa(Лох "продолжить" "остановить" \
            "Хотите продолжить программу?")     \
        " программу"))
```

При использовании awen() может хотите проверить без ошибки если строка похожа на целое число. Это возможно сделать с помощью nanpaLaTawa(), которая перемещает только если все строки ей так похожи.

```ilo li sina
неЧисло:
    возможноеЧисло = kamaJoTanJan("Скажите число!")
    nanpaLaTawa(число возможноеЧисло)
    tokiELinja("'" возможноеЧисло "' не число!")
    tawa(неЧисло)

число:
    tokiELinja("Вам " возможноеЧисло " лет? Так долго, страик! хахаха")
```

Есть маленькая деталь переходов: GOTO не перемещает до полного выполнения строки. До тех пор, GOTO работают как нормальная функция и могут вернуть результат, который можно даться другой функци или сохраниться.

```ilo li sina
    любитЯблока = niLaTawa(Конец "да" "нет"  \
                           "Любите яблока?")
    
СпрошиватьСнова: 
    # Если не говорил ничего, спрашивает еще раз. Если говорил что-нибудь кроме сообщения да, то 
    # говорит "Да ладно!". 
    alaLaTawa(СпрошиватьСнова niLaTawa(Конец "Я люблю яблока" _                                \
                                    любитЯблока "? Не любишь яблока? Да ладно! Скажи, что ты " \
                                    "любишь яблока прям щас!"))  

    tokiELinja("Да ладно!")
    tawa(СпрошиватьСнова)

Конец:
    tokiELinja("Офигенно! Считаю, что мы друзья!")
```

### ***Переменные***

Есть переменные для хранения данных. Для хранения строки напишите имя переменной и что-нибудь, которое строка или возвращает строку, с знаком равенства между ними. Можно дать строку в них функции и другим переменным.

```ilo li sina
    a = "test"
    б = a
    tokiELinja(б) # Скажет "test"

    a = kamaJoTanJan("Что вам будет угодно?")
    tokiELinja("У вас никогда не будет " a) # Если ответил "деньги", то скажет "У вас никогда не будет деньни".

    вещь = "вещь"
Больше:
    niLaTawa(Хватит "нет" "да"          \
             "Вы хотите больше вещей?")
    вещь = wan(вещь вещь)
    tawa(Больше)
Хватит:
    tokiELinja(вещь) # Если пользователь выбирал "да" 4 раза, то скажет "вещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещьвещь".
```

### ***Маленькие Особенности***

#### *Управляющие символы:*

Можно добавить управляющий символ в литерале, написав обратную косую черту и его символ.

 - \\n - Перенос строки.
 - \\t - Табуляция.
 - \\v - Вертикальная табуляция.
 - \\b - Backspace.
 - \\" - Позволяет сделать кавычки в строках.
 - \\\\ - Позволяет сделать обратные косые черты в строках.

Например:

```ilo li sina
    toki("Это язык \"ilo li sina\" !\b\b") # Скажет 'Это язык "ilo li sina"'.
```

#### *Многострочные инструкции:*

Инструкции в ilo li sina разделяются переносами строки - так сказать, каждая инструкция начинается и заканчивается в одной строке. Но можно сделать одну инструкцию многострочной, писав обратную косую черту в конце каждой строки инструкции кроме последней.

```ilo li sina
    aбв  \
    =    \
    "да"
    niLaTawa(Знает aбв "нет"                     \
            "Знаете ли вы пряничного человека?")

    tokiELinja("Это сообщение " "в" \
               " многих"            \
               " строках!")

    tawa(Конец)

Знает: tokiELinja(          \
                            \
                            \
                            \
                            \
                            \
                            \
                  "Круто!")

Конец:
```

#### *Получение EOF:*

kamaJoTanJan() и niLaTawa() завершают программу при получении EOF.

Вот почему: все языка - IO. Если нет ввода, то ничего не может сделать. Хотя, это и позволяет чтение из файлов. К примеру, если вы бы создали файл с именем "temp.txt", написали текста в нем и запустил "temp.txt | ilo_li_sina \<имя прогаммы\>", то программа получил бы ввод из него без бесконечного цикла.

#### *Предварительно инициализированные переменные:*

Немного переменных инициализируются до начала каждой программы на ilo li sina.

**__nanpa_Ilo_Li_Sina** - Версия интерпретатора.

**__nimi_Ilo_Li_Sina** - Путь к испольняемому интерпретатора.

**__nimi_lipu** - Путь к выбранной программе.

**__nimi_jan** - Имеет имя пользователя, полученное из вызова функцию pokiPiLawaOS("USER" "USERNAME" "LOGNAME"). Если не удалось, то имеет пустую строку.

**_** - Сокращение пустой строки ("").